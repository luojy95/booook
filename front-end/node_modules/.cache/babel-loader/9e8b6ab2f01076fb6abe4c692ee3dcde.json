{"ast":null,"code":"var _objectSpread = require(\"/home/zecheng3/workspace/cs498rk/rk_project/front-end/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _slicedToArray = require(\"/home/zecheng3/workspace/cs498rk/rk_project/front-end/node_modules/@babel/runtime/helpers/slicedToArray\");\n\n/**\n * Utilities\n * @module utils\n * @borrows module:auth_token as generate_auth_token\n */\nvar crypto = require(\"crypto\");\n\nvar querystring = require(\"querystring\");\n\nvar urlParse = require(\"url\").parse; // Functions used internally\n\n\nvar compact = require(\"lodash/compact\");\n\nvar defaults = require(\"lodash/defaults\");\n\nvar find = require(\"lodash/find\");\n\nvar first = require(\"lodash/first\");\n\nvar identity = require(\"lodash/identity\");\n\nvar isFunction = require(\"lodash/isFunction\");\n\nvar isPlainObject = require(\"lodash/isPlainObject\");\n\nvar last = require(\"lodash/last\");\n\nvar map = require(\"lodash/map\");\n\nvar sortBy = require(\"lodash/sortBy\");\n\nvar take = require(\"lodash/take\");\n\nvar at = require(\"lodash/at\"); // Exposed by the module\n\n\nvar clone = require(\"lodash/clone\");\n\nvar extend = require(\"lodash/extend\");\n\nvar filter = require(\"lodash/filter\");\n\nvar includes = require(\"lodash/includes\");\n\nvar isArray = require(\"lodash/isArray\");\n\nvar isEmpty = require(\"lodash/isEmpty\");\n\nvar isNumber = require(\"lodash/isNumber\");\n\nvar isObject = require(\"lodash/isObject\");\n\nvar isString = require(\"lodash/isString\");\n\nvar isUndefined = require(\"lodash/isUndefined\");\n\nvar keys = require(\"lodash/keys\");\n\nvar merge = require(\"lodash/merge\");\n\nvar config = require(\"../config\");\n\nvar generate_token = require(\"../auth_token\");\n\nvar utf8_encode = require('./utf8_encode');\n\nvar crc32 = require('./crc32');\n\nvar ensurePresenceOf = require('./ensurePresenceOf');\n\nvar ensureOption = require('./ensureOption').defaults(config());\n\nvar entries = require('./entries');\n\nmodule.exports = {\n  at: at,\n  clone: clone,\n  extend: extend,\n  filter: filter,\n  includes: includes,\n  isArray: isArray,\n  isEmpty: isEmpty,\n  isNumber: isNumber,\n  isObject: isObject,\n  isString: isString,\n  isUndefined: isUndefined,\n  keys: keys,\n  merge: merge,\n  ensurePresenceOf: ensurePresenceOf\n};\nexports = module.exports;\nvar utils = module.exports;\n\nexports.generate_auth_token = function generate_auth_token(options) {\n  var token_options = Object.assign({}, config().auth_token, options);\n  return generate_token(token_options);\n};\n\nexports.CF_SHARED_CDN = \"d3jpl91pxevbkh.cloudfront.net\";\nexports.OLD_AKAMAI_SHARED_CDN = \"cloudinary-a.akamaihd.net\";\nexports.AKAMAI_SHARED_CDN = \"res.cloudinary.com\";\nexports.SHARED_CDN = exports.AKAMAI_SHARED_CDN;\n\ntry {\n  exports.VERSION = require('../../package.json').version;\n} catch (error) {}\n\nexports.USER_AGENT = \"CloudinaryNodeJS/\".concat(exports.VERSION); // Add platform information to the USER_AGENT header\n// This is intended for platform information and not individual applications!\n\nexports.userPlatform = \"\";\n\nexports.getUserAgent = function getUserAgent() {\n  if (isEmpty(utils.userPlatform)) {\n    return \"\".concat(utils.USER_AGENT);\n  } else {\n    return \"\".concat(utils.userPlatform, \" \").concat(utils.USER_AGENT);\n  }\n};\n\nvar DEFAULT_RESPONSIVE_WIDTH_TRANSFORMATION = {\n  width: \"auto\",\n  crop: \"limit\"\n};\nexports.DEFAULT_POSTER_OPTIONS = {\n  format: 'jpg',\n  resource_type: 'video'\n};\nexports.DEFAULT_VIDEO_SOURCE_TYPES = ['webm', 'mp4', 'ogv'];\nvar CONDITIONAL_OPERATORS = {\n  \"=\": 'eq',\n  \"!=\": 'ne',\n  \"<\": 'lt',\n  \">\": 'gt',\n  \"<=\": 'lte',\n  \">=\": 'gte',\n  \"&&\": 'and',\n  \"||\": 'or',\n  \"*\": \"mul\",\n  \"/\": \"div\",\n  \"+\": \"add\",\n  \"-\": \"sub\"\n};\nvar PREDEFINED_VARS = {\n  \"aspect_ratio\": \"ar\",\n  \"aspectRatio\": \"ar\",\n  \"current_page\": \"cp\",\n  \"currentPage\": \"cp\",\n  \"face_count\": \"fc\",\n  \"faceCount\": \"fc\",\n  \"height\": \"h\",\n  \"initial_aspect_ratio\": \"iar\",\n  \"initial_height\": \"ih\",\n  \"initial_width\": \"iw\",\n  \"initialAspectRatio\": \"iar\",\n  \"initialHeight\": \"ih\",\n  \"initialWidth\": \"iw\",\n  \"page_count\": \"pc\",\n  \"page_x\": \"px\",\n  \"page_y\": \"py\",\n  \"pageCount\": \"pc\",\n  \"pageX\": \"px\",\n  \"pageY\": \"py\",\n  \"tags\": \"tags\",\n  \"width\": \"w\"\n};\nvar LAYER_KEYWORD_PARAMS = {\n  font_weight: \"normal\",\n  font_style: \"normal\",\n  text_decoration: \"none\",\n  text_align: null,\n  stroke: \"none\"\n};\n\nfunction textStyle(layer) {\n  var font_family = layer[\"font_family\"];\n  var font_size = layer[\"font_size\"];\n  var keywords = [];\n\n  for (var attr in LAYER_KEYWORD_PARAMS) {\n    var default_value = LAYER_KEYWORD_PARAMS[attr];\n    var attr_value = layer[attr] || default_value;\n\n    if (attr_value !== default_value) {\n      keywords.push(attr_value);\n    }\n  }\n\n  var letter_spacing = layer[\"letter_spacing\"];\n\n  if (letter_spacing) {\n    keywords.push(\"letter_spacing_\".concat(letter_spacing));\n  }\n\n  var line_spacing = layer[\"line_spacing\"];\n\n  if (line_spacing) {\n    keywords.push(\"line_spacing_\".concat(line_spacing));\n  }\n\n  if (font_size || font_family || !isEmpty(keywords)) {\n    if (!font_family) {\n      throw \"Must supply font_family for text in overlay/underlay\";\n    }\n\n    if (!font_size) {\n      throw \"Must supply font_size for text in overlay/underlay\";\n    }\n\n    keywords.unshift(font_size);\n    keywords.unshift(font_family);\n    return compact(keywords).join(\"_\");\n  }\n}\n/**\n * Normalize an offset value\n * @param {String} expression a decimal value which may have a 'p' or '%' postfix. E.g. '35%', '0.4p'\n * @return {Object|String} a normalized String of the input value if possible otherwise the value itself\n */\n\n\nfunction normalize_expression(expression) {\n  if (!isString(expression) || expression.length === 0 || expression.match(/^!.+!$/)) {\n    return expression;\n  }\n\n  var operators = \"\\\\|\\\\||>=|<=|&&|!=|>|=|<|/|-|\\\\+|\\\\*\";\n  var pattern = \"((\" + operators + \")(?=[ _])|\" + Object.keys(PREDEFINED_VARS).join(\"|\") + \")\";\n  var replaceRE = new RegExp(pattern, \"g\");\n  expression = expression.replace(replaceRE, function (match) {\n    return CONDITIONAL_OPERATORS[match] || PREDEFINED_VARS[match];\n  });\n  return expression.replace(/[ _]+/g, '_');\n}\n/**\n * Parse \"if\" parameter\n * Translates the condition if provided.\n * @private\n * @return {string} \"if_\" + ifValue\n */\n\n\nfunction process_if(ifValue) {\n  if (ifValue) {\n    return \"if_\" + normalize_expression(ifValue);\n  } else {\n    return ifValue;\n  }\n}\n/**\n * Parse layer options\n * @private\n * @param {object|*} layer The layer to parse.\n * @return {string} layer transformation string\n */\n\n\nfunction process_layer(layer) {\n  var result = '';\n\n  if (isPlainObject(layer)) {\n    if (layer[\"resource_type\"] === \"fetch\" || layer[\"url\"] != null) {\n      result = \"fetch:\".concat(base64EncodeURL(layer['url']));\n    } else {\n      var public_id = layer[\"public_id\"];\n      var format = layer[\"format\"];\n      var resource_type = layer[\"resource_type\"] || \"image\";\n      var type = layer[\"type\"] || \"upload\";\n      var text = layer[\"text\"];\n      var style = null;\n      var components = [];\n\n      if (!isEmpty(public_id)) {\n        public_id = public_id.replace(new RegExp(\"/\", 'g'), \":\");\n\n        if (format != null) {\n          public_id = \"\".concat(public_id, \".\").concat(format);\n        }\n      }\n\n      if (isEmpty(text) && resource_type !== \"text\") {\n        if (isEmpty(public_id)) {\n          throw \"Must supply public_id for resource_type layer_parameter\";\n        }\n\n        if (resource_type === \"subtitles\") {\n          style = textStyle(layer);\n        }\n      } else {\n        resource_type = \"text\";\n        type = null; // type is ignored for text layers\n\n        style = textStyle(layer);\n\n        if (!isEmpty(text)) {\n          if (!(isEmpty(public_id) ^ isEmpty(style))) {\n            throw \"Must supply either style parameters or a public_id when providing text parameter in a text overlay/underlay\";\n          }\n\n          var re = /\\$\\([a-zA-Z]\\w*\\)/g;\n          var start = 0;\n          var textSource = smart_escape(decodeURIComponent(text), /[,\\/]/g);\n          text = \"\";\n          var res;\n\n          while (res = re.exec(textSource)) {\n            text += smart_escape(textSource.slice(start, res.index));\n            text += res[0];\n            start = res.index + res[0].length;\n          }\n\n          text += encodeURIComponent(textSource.slice(start));\n        }\n      }\n\n      if (resource_type !== \"image\") {\n        components.push(resource_type);\n      }\n\n      if (type !== \"upload\") {\n        components.push(type);\n      }\n\n      components.push(style);\n      components.push(public_id);\n      components.push(text);\n      result = compact(components).join(\":\");\n    }\n  } else if (/^fetch:.+/.test(layer)) {\n    result = \"fetch:\".concat(base64EncodeURL(layer.substr(6)));\n  } else {\n    result = layer;\n  }\n\n  return result;\n}\n\nfunction base64EncodeURL(url) {\n  var ignore;\n\n  try {\n    url = decodeURI(url);\n  } catch (error) {\n    ignore = error;\n  }\n\n  url = encodeURI(url);\n  return base64Encode(url);\n}\n\nfunction base64Encode(input) {\n  if (!(input instanceof Buffer)) {\n    input = new Buffer.from(String(input), 'binary');\n  }\n\n  return input.toString('base64');\n}\n\nexports.build_upload_params = function build_upload_params(options) {\n  var params = {\n    access_mode: options.access_mode,\n    allowed_formats: options.allowed_formats && utils.build_array(options.allowed_formats).join(\",\"),\n    async: utils.as_safe_bool(options.async),\n    backup: utils.as_safe_bool(options.backup),\n    callback: options.callback,\n    colors: utils.as_safe_bool(options.colors),\n    discard_original_filename: utils.as_safe_bool(options.discard_original_filename),\n    eager: utils.build_eager(options.eager),\n    eager_async: utils.as_safe_bool(options.eager_async),\n    eager_notification_url: options.eager_notification_url,\n    exif: utils.as_safe_bool(options.exif),\n    faces: utils.as_safe_bool(options.faces),\n    folder: options.folder,\n    format: options.format,\n    image_metadata: utils.as_safe_bool(options.image_metadata),\n    invalidate: utils.as_safe_bool(options.invalidate),\n    moderation: options.moderation,\n    notification_url: options.notification_url,\n    overwrite: utils.as_safe_bool(options.overwrite),\n    phash: utils.as_safe_bool(options.phash),\n    proxy: options.proxy,\n    public_id: options.public_id,\n    quality_analysis: utils.as_safe_bool(options.quality_analysis),\n    responsive_breakpoints: utils.generate_responsive_breakpoints_string(options[\"responsive_breakpoints\"]),\n    return_delete_token: utils.as_safe_bool(options.return_delete_token),\n    timestamp: exports.timestamp(),\n    transformation: utils.generate_transformation_string(clone(options)),\n    type: options.type,\n    unique_filename: utils.as_safe_bool(options.unique_filename),\n    upload_preset: options.upload_preset,\n    use_filename: utils.as_safe_bool(options.use_filename)\n  };\n  return utils.updateable_resource_params(options, params);\n};\n\nexports.timestamp = function timestamp() {\n  return Math.floor(new Date().getTime() / 1000);\n};\n/**\n * Deletes `option_name` from `options` and return the value if present.\n * If `options` doesn't contain `option_name` the default value is returned.\n * @param {Object} options a collection\n * @param {String} option_name the name (key) of the desired value\n * @param {*} [default_value] the value to return is option_name is missing\n */\n\n\nexports.option_consume = function option_consume(options, option_name, default_value) {\n  var result = options[option_name];\n  delete options[option_name];\n\n  if (result != null) {\n    return result;\n  } else {\n    return default_value;\n  }\n};\n\nexports.build_array = function build_array(arg) {\n  if (arg == null) {\n    return [];\n  } else if (isArray(arg)) {\n    return arg;\n  } else {\n    return [arg];\n  }\n};\n\nexports.encode_double_array = function encode_double_array(array) {\n  array = utils.build_array(array);\n\n  if (array.length > 0 && isArray(array[0])) {\n    return array.map(function (e) {\n      return utils.build_array(e).join(\",\");\n    }).join(\"|\");\n  } else {\n    return array.join(\",\");\n  }\n};\n\nexports.encode_key_value = function encode_key_value(arg) {\n  if (isObject(arg)) {\n    return entries(args).map(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          k = _ref2[0],\n          v = _ref2[1];\n\n      return \"\".concat(k, \"=\").concat(v);\n    }).join('|');\n  } else {\n    return arg;\n  }\n};\n\nexports.encode_context = function encode_context(arg) {\n  var k, pairs, v;\n\n  if (isObject(arg)) {\n    return entries(arg).map(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n          k = _ref4[0],\n          v = _ref4[1];\n\n      return \"\".concat(k, \"=\").concat(v.replace(/([=|])/g, '\\\\$&'));\n    }).join('|');\n  } else {\n    return arg;\n  }\n};\n\nexports.build_eager = function build_eager(transformations) {\n  return utils.build_array(transformations).map(function (transformation) {\n    var transformationString = utils.generate_transformation_string(clone(transformation));\n    var format = transformation.format;\n    return format == null ? transformationString : \"\".concat(transformationString, \"/\").concat(format);\n  }).join('|');\n};\n/**\n * Build the custom headers for the request\n * @private\n * @param headers\n * @return {Array<string>|object|string} An object of name and value,\n *         an array of header strings, or a string of headers\n */\n\n\nexports.build_custom_headers = function build_custom_headers(headers) {\n  if (headers == null) {\n    return void 0;\n  } else if (isArray(headers)) {\n    return headers.join(\"\\n\");\n  } else if (isObject(headers)) {\n    return entries(headers).map(function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 2),\n          k = _ref6[0],\n          v = _ref6[1];\n\n      return \"\".concat(k, \":\").concat(v);\n    }).join(\"\\n\");\n  } else {\n    return headers;\n  }\n};\n\nvar TRANSFORMATION_PARAMS = ['angle', 'aspect_ratio', 'audio_codec', 'audio_frequency', 'background', 'bit_rate', 'border', 'color', 'color_space', 'crop', 'default_image', 'delay', 'density', 'dpr', 'duration', 'effect', 'end_offset', 'fetch_format', 'flags', 'fps', 'gravity', 'height', 'if', 'keyframe_interval', 'offset', 'opacity', 'overlay', 'page', 'prefix', 'quality', 'radius', 'raw_transformation', 'responsive_width', 'size', 'start_offset', 'streaming_profile', 'transformation', 'underlay', 'variables', 'video_codec', 'video_sampling', 'width', 'x', 'y', 'zoom' // + any key that starts with '$'\n];\n\nexports.generate_transformation_string = function generate_transformation_string(options) {\n  if (utils.isString(options)) {\n    return options;\n  }\n\n  if (isArray(options)) {\n    return options.map(function (t) {\n      return utils.generate_transformation_string(clone(t));\n    }).filter(utils.present).join('/');\n  }\n\n  var responsive_width = utils.option_consume(options, \"responsive_width\", config().responsive_width);\n  var width = options[\"width\"];\n  var height = options[\"height\"];\n  var size = utils.option_consume(options, \"size\");\n\n  if (size) {\n    var _size$split, _size$split2;\n\n    var _ref7 = (_size$split = size.split(\"x\"), _size$split2 = _slicedToArray(_size$split, 2), width = _size$split2[0], height = _size$split2[1], _size$split);\n\n    var _ref8 = _slicedToArray(_ref7, 2);\n\n    options[\"width\"] = _ref8[0];\n    options[\"height\"] = _ref8[1];\n  }\n\n  var has_layer = options.overlay || options.underlay;\n  var crop = utils.option_consume(options, \"crop\");\n  var angle = utils.build_array(utils.option_consume(options, \"angle\")).join(\".\");\n  var no_html_sizes = has_layer || utils.present(angle) || crop === \"fit\" || crop === \"limit\" || responsive_width;\n\n  if (width && (width.toString().indexOf(\"auto\") === 0 || no_html_sizes || parseFloat(width) < 1)) {\n    delete options[\"width\"];\n  }\n\n  if (height && (no_html_sizes || parseFloat(height) < 1)) {\n    delete options[\"height\"];\n  }\n\n  var background = utils.option_consume(options, \"background\");\n  background = background && background.replace(/^#/, \"rgb:\");\n  var color = utils.option_consume(options, \"color\");\n  color = color && color.replace(/^#/, \"rgb:\");\n  var base_transformations = utils.build_array(utils.option_consume(options, \"transformation\", []));\n  var named_transformation = [];\n\n  if (base_transformations.length !== 0 && filter(base_transformations, isObject).length > 0) {\n    base_transformations = map(base_transformations, function (base_transformation) {\n      if (isObject(base_transformation)) {\n        return utils.generate_transformation_string(clone(base_transformation));\n      } else {\n        return utils.generate_transformation_string({\n          transformation: base_transformation\n        });\n      }\n    });\n  } else {\n    named_transformation = base_transformations.join(\".\");\n    base_transformations = [];\n  }\n\n  var effect = utils.option_consume(options, \"effect\");\n\n  if (isArray(effect)) {\n    effect = effect.join(\":\");\n  } else if (isObject(effect)) {\n    effect = entries(effect).map(function (_ref9) {\n      var _ref10 = _slicedToArray(_ref9, 2),\n          key = _ref10[0],\n          value = _ref10[1];\n\n      return \"\".concat(key, \":\").concat(value);\n    });\n  }\n\n  var border = utils.option_consume(options, \"border\");\n\n  if (isObject(border)) {\n    border = \"\".concat(border.width != null ? border.width : 2, \"px_solid_\").concat((border.color != null ? border.color : \"black\").replace(/^#/, 'rgb:'));\n  } else if (/^\\d+$/.exec(border)) {\n    //fallback to html border attributes\n    options.border = border;\n    border = void 0;\n  }\n\n  var flags = utils.build_array(utils.option_consume(options, \"flags\")).join(\".\");\n  var dpr = utils.option_consume(options, \"dpr\", config().dpr);\n\n  if (options[\"offset\"] != null) {\n    var _split_range = split_range(utils.option_consume(options, \"offset\"));\n\n    var _split_range2 = _slicedToArray(_split_range, 2);\n\n    options[\"start_offset\"] = _split_range2[0];\n    options[\"end_offset\"] = _split_range2[1];\n  }\n\n  var overlay = process_layer(utils.option_consume(options, \"overlay\"));\n  var underlay = process_layer(utils.option_consume(options, \"underlay\"));\n  var ifValue = process_if(utils.option_consume(options, \"if\"));\n  var fps = utils.option_consume(options, 'fps');\n\n  if (isArray(fps)) {\n    fps = fps.join('-');\n  }\n\n  var params = {\n    a: normalize_expression(angle),\n    ar: normalize_expression(utils.option_consume(options, \"aspect_ratio\")),\n    b: background,\n    bo: border,\n    c: crop,\n    co: color,\n    dpr: normalize_expression(dpr),\n    e: normalize_expression(effect),\n    fl: flags,\n    fps: fps,\n    h: normalize_expression(height),\n    ki: normalize_expression(utils.option_consume(options, \"keyframe_interval\")),\n    l: overlay,\n    o: normalize_expression(utils.option_consume(options, \"opacity\")),\n    q: normalize_expression(utils.option_consume(options, \"quality\")),\n    r: normalize_expression(utils.option_consume(options, \"radius\")),\n    t: named_transformation,\n    u: underlay,\n    w: normalize_expression(width),\n    x: normalize_expression(utils.option_consume(options, \"x\")),\n    y: normalize_expression(utils.option_consume(options, \"y\")),\n    z: normalize_expression(utils.option_consume(options, \"zoom\"))\n  };\n  var simple_params = {\n    audio_codec: \"ac\",\n    audio_frequency: \"af\",\n    bit_rate: 'br',\n    color_space: \"cs\",\n    default_image: \"d\",\n    delay: \"dl\",\n    density: \"dn\",\n    duration: \"du\",\n    end_offset: \"eo\",\n    fetch_format: \"f\",\n    gravity: \"g\",\n    page: \"pg\",\n    prefix: \"p\",\n    start_offset: \"so\",\n    streaming_profile: \"sp\",\n    video_codec: \"vc\",\n    video_sampling: \"vs\"\n  };\n\n  for (var param in simple_params) {\n    var short = simple_params[param];\n    var value = utils.option_consume(options, param);\n\n    if (value !== undefined) {\n      params[short] = value;\n    }\n  }\n\n  if (params[\"vc\"] != null) {\n    params[\"vc\"] = process_video_params(params[\"vc\"]);\n  }\n\n  [\"so\", \"eo\", \"du\"].forEach(function (short) {\n    if (params[short] !== undefined) {\n      params[short] = norm_range_value(params[short]);\n    }\n  });\n  var variablesParam = utils.option_consume(options, \"variables\", []);\n  var variables = entries(options).filter(function (_ref11) {\n    var _ref12 = _slicedToArray(_ref11, 2),\n        key = _ref12[0],\n        value = _ref12[1];\n\n    return key.startsWith('$');\n  }).map(function (_ref13) {\n    var _ref14 = _slicedToArray(_ref13, 2),\n        key = _ref14[0],\n        value = _ref14[1];\n\n    delete options[key];\n    return \"\".concat(key, \"_\").concat(normalize_expression(value));\n  }).sort().concat(variablesParam.map(function (_ref15) {\n    var _ref16 = _slicedToArray(_ref15, 2),\n        name = _ref16[0],\n        value = _ref16[1];\n\n    return \"\".concat(name, \"_\").concat(normalize_expression(value));\n  })).join(',');\n  var transformations = entries(params).filter(function (_ref17) {\n    var _ref18 = _slicedToArray(_ref17, 2),\n        key = _ref18[0],\n        value = _ref18[1];\n\n    return utils.present(value);\n  }).map(function (_ref19) {\n    var _ref20 = _slicedToArray(_ref19, 2),\n        key = _ref20[0],\n        value = _ref20[1];\n\n    return key + '_' + value;\n  }).sort().join(',');\n  var raw_transformation = utils.option_consume(options, 'raw_transformation');\n  transformations = compact([ifValue, variables, transformations, raw_transformation]).join(\",\");\n  base_transformations.push(transformations);\n  transformations = base_transformations;\n\n  if (responsive_width) {\n    var responsive_width_transformation = config().responsive_width_transformation || DEFAULT_RESPONSIVE_WIDTH_TRANSFORMATION;\n    transformations.push(utils.generate_transformation_string(clone(responsive_width_transformation)));\n  }\n\n  if (width != null && width.toString().indexOf(\"auto\") === 0 || responsive_width) {\n    options.responsive = true;\n  }\n\n  if (dpr === \"auto\") {\n    options.hidpi = true;\n  }\n\n  return filter(transformations, utils.present).join(\"/\");\n};\n\nexports.updateable_resource_params = function updateable_resource_params(options) {\n  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (options.access_control != null) {\n    params.access_control = utils.jsonArrayParam(options.access_control);\n  }\n\n  if (options.auto_tagging != null) {\n    params.auto_tagging = options.auto_tagging;\n  }\n\n  if (options.background_removal != null) {\n    params.background_removal = options.background_removal;\n  }\n\n  if (options.categorization != null) {\n    params.categorization = options.categorization;\n  }\n\n  if (options.context != null) {\n    params.context = utils.encode_context(options.context);\n  }\n\n  if (options.custom_coordinates != null) {\n    params.custom_coordinates = utils.encode_double_array(options.custom_coordinates);\n  }\n\n  if (options.detection != null) {\n    params.detection = options.detection;\n  }\n\n  if (options.face_coordinates != null) {\n    params.face_coordinates = utils.encode_double_array(options.face_coordinates);\n  }\n\n  if (options.headers != null) {\n    params.headers = utils.build_custom_headers(options.headers);\n  }\n\n  if (options.notification_url != null) {\n    params.notification_url = options.notification_url;\n  }\n\n  if (options.ocr != null) {\n    params.ocr = options.ocr;\n  }\n\n  if (options.raw_convert != null) {\n    params.raw_convert = options.raw_convert;\n  }\n\n  if (options.similarity_search != null) {\n    params.similarity_search = options.similarity_search;\n  }\n\n  if (options.tags != null) {\n    params.tags = utils.build_array(options.tags).join(\",\");\n  }\n\n  return params;\n};\n/**\n * A list of keys used by the url() function.\n * @private\n */\n\n\nvar URL_KEYS = ['api_secret', 'auth_token', 'cdn_subdomain', 'cloud_name', 'cname', 'format', 'private_cdn', 'resource_type', 'secure', 'secure_cdn_subdomain', 'secure_distribution', 'shorten', 'sign_url', 'ssl_detected', 'type', 'url_suffix', 'use_root_path', 'version'];\n/**\n * Create a new object with only URL parameters\n * @param {object} options The source object\n * @return {Object} An object containing only URL parameters\n */\n\nexports.extractUrlParams = function extractUrlParams(options) {\n  return utils.only.apply(utils, [options].concat(URL_KEYS));\n};\n/**\n * Create a new object with only transformation parameters\n * @param {object} options The source object\n * @return {Object} An object containing only transformation parameters\n */\n\n\nexports.extractTransformationParams = function extractTransformationParams(options) {\n  return utils.only.apply(utils, [options].concat(TRANSFORMATION_PARAMS));\n};\n/**\n * Handle the format parameter for fetch urls\n * @private\n * @param options url and transformation options. This argument may be changed by the function!\n */\n\n\nexports.patchFetchFormat = function patchFetchFormat() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (options.type === \"fetch\") {\n    if (options.fetch_format == null) {\n      options.fetch_format = utils.option_consume(options, \"format\");\n    }\n  }\n};\n\nexports.url = function url(public_id) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var signature, source_to_sign;\n  utils.patchFetchFormat(options);\n  var type = utils.option_consume(options, \"type\", null);\n  var transformation = utils.generate_transformation_string(options);\n  var resource_type = utils.option_consume(options, \"resource_type\", \"image\");\n  var version = utils.option_consume(options, \"version\");\n  var format = utils.option_consume(options, \"format\");\n  var cloud_name = utils.option_consume(options, \"cloud_name\", config().cloud_name);\n\n  if (!cloud_name) {\n    throw \"Unknown cloud_name\";\n  }\n\n  var private_cdn = utils.option_consume(options, \"private_cdn\", config().private_cdn);\n  var secure_distribution = utils.option_consume(options, \"secure_distribution\", config().secure_distribution);\n  var secure = utils.option_consume(options, \"secure\", null);\n  var ssl_detected = utils.option_consume(options, \"ssl_detected\", config().ssl_detected);\n\n  if (secure === null) {\n    secure = ssl_detected || config().secure;\n  }\n\n  var cdn_subdomain = utils.option_consume(options, \"cdn_subdomain\", config().cdn_subdomain);\n  var secure_cdn_subdomain = utils.option_consume(options, \"secure_cdn_subdomain\", config().secure_cdn_subdomain);\n  var cname = utils.option_consume(options, \"cname\", config().cname);\n  var shorten = utils.option_consume(options, \"shorten\", config().shorten);\n  var sign_url = utils.option_consume(options, \"sign_url\", config().sign_url);\n  var api_secret = utils.option_consume(options, \"api_secret\", config().api_secret);\n  var url_suffix = utils.option_consume(options, \"url_suffix\");\n  var use_root_path = utils.option_consume(options, \"use_root_path\", config().use_root_path);\n  var auth_token = utils.option_consume(options, \"auth_token\");\n\n  if (auth_token !== false) {\n    auth_token = exports.merge(config().auth_token, auth_token);\n  }\n\n  var preloaded = /^(image|raw)\\/([a-z0-9_]+)\\/v(\\d+)\\/([^#]+)$/.exec(public_id);\n\n  if (preloaded) {\n    resource_type = preloaded[1];\n    type = preloaded[2];\n    version = preloaded[3];\n    public_id = preloaded[4];\n  }\n\n  var original_source = public_id;\n\n  if (public_id == null) {\n    return original_source;\n  }\n\n  public_id = public_id.toString();\n\n  if (type === null && public_id.match(/^https?:\\//i)) {\n    return original_source;\n  }\n\n  var _finalize_resource_ty = finalize_resource_type(resource_type, type, url_suffix, use_root_path, shorten);\n\n  var _finalize_resource_ty2 = _slicedToArray(_finalize_resource_ty, 2);\n\n  resource_type = _finalize_resource_ty2[0];\n  type = _finalize_resource_ty2[1];\n\n  var _finalize_source = finalize_source(public_id, format, url_suffix);\n\n  var _finalize_source2 = _slicedToArray(_finalize_source, 2);\n\n  public_id = _finalize_source2[0];\n  source_to_sign = _finalize_source2[1];\n\n  if (source_to_sign.indexOf(\"/\") > 0 && !source_to_sign.match(/^v[0-9]+/) && !source_to_sign.match(/^https?:\\//)) {\n    if (version == null) {\n      version = 1;\n    }\n  }\n\n  if (version != null) {\n    version = \"v\".concat(version);\n  }\n\n  transformation = transformation.replace(/([^:])\\/\\//g, '$1/');\n\n  if (sign_url && isEmpty(auth_token)) {\n    var to_sign = [transformation, source_to_sign].filter(function (part) {\n      return part != null && part !== '';\n    }).join('/');\n\n    try {\n      for (var i = 0; to_sign !== decodeURIComponent(to_sign) && i < 10; i++) {\n        to_sign = decodeURIComponent(to_sign);\n      }\n    } catch (error) {}\n\n    var shasum = crypto.createHash('sha1');\n    shasum.update(utf8_encode(to_sign + api_secret), 'binary');\n    signature = shasum.digest('base64').replace(/\\//g, '_').replace(/\\+/g, '-').substring(0, 8);\n    signature = \"s--\".concat(signature, \"--\");\n  }\n\n  var prefix = unsigned_url_prefix(public_id, cloud_name, private_cdn, cdn_subdomain, secure_cdn_subdomain, cname, secure, secure_distribution);\n  var resultUrl = [prefix, resource_type, type, signature, transformation, version, public_id].filter(function (part) {\n    return part != null && part !== '';\n  }).join('/');\n\n  if (sign_url && !isEmpty(auth_token)) {\n    auth_token.url = urlParse(resultUrl).path;\n    var token = generate_token(auth_token);\n    resultUrl += \"?\".concat(token);\n  }\n\n  return resultUrl;\n};\n\nexports.video_url = function video_url(public_id, options) {\n  options = extend({\n    resource_type: 'video'\n  }, options);\n  return utils.url(public_id, options);\n};\n\nfunction finalize_source(source, format, url_suffix) {\n  var source_to_sign;\n  source = source.replace(/([^:])\\/\\//g, '$1/');\n\n  if (source.match(/^https?:\\//i)) {\n    source = smart_escape(source);\n    source_to_sign = source;\n  } else {\n    source = encodeURIComponent(decodeURIComponent(source)).replace(/%3A/g, \":\").replace(/%2F/g, \"/\");\n    source_to_sign = source;\n\n    if (!!url_suffix) {\n      if (url_suffix.match(/[\\.\\/]/)) {\n        throw new Error('url_suffix should not include . or /');\n      }\n\n      source = source + '/' + url_suffix;\n    }\n\n    if (format != null) {\n      source = source + '.' + format;\n      source_to_sign = source_to_sign + '.' + format;\n    }\n  }\n\n  return [source, source_to_sign];\n}\n\nexports.video_thumbnail_url = function video_thumbnail_url(public_id, options) {\n  options = extend({}, exports.DEFAULT_POSTER_OPTIONS, options);\n  return utils.url(public_id, options);\n};\n\nfunction finalize_resource_type(resource_type, type, url_suffix, use_root_path, shorten) {\n  if (type == null) {\n    type = 'upload';\n  }\n\n  if (url_suffix != null) {\n    if (resource_type === 'image' && type === 'upload') {\n      resource_type = \"images\";\n      type = null;\n    } else if (resource_type === 'image' && type === 'private') {\n      resource_type = 'private_images';\n      type = null;\n    } else if (resource_type === 'image' && type === 'authenticated') {\n      resource_type = 'authenticated_images';\n      type = null;\n    } else if (resource_type === 'raw' && type === 'upload') {\n      resource_type = 'files';\n      type = null;\n    } else if (resource_type === 'video' && type === 'upload') {\n      resource_type = 'videos';\n      type = null;\n    } else {\n      throw new Error(\"URL Suffix only supported for image/upload, image/private, image/authenticated, video/upload and raw/upload\");\n    }\n  }\n\n  if (use_root_path) {\n    if (resource_type === 'image' && type === 'upload' || resource_type === 'images' && type == null) {\n      resource_type = null;\n      type = null;\n    } else {\n      throw new Error(\"Root path only supported for image/upload\");\n    }\n  }\n\n  if (shorten && resource_type === 'image' && type === 'upload') {\n    resource_type = 'iu';\n    type = null;\n  }\n\n  return [resource_type, type];\n} // cdn_subdomain and secure_cdn_subdomain\n// 1) Customers in shared distribution (e.g. res.cloudinary.com)\n//   if cdn_domain is true uses res-[1-5].cloudinary.com for both http and https. Setting secure_cdn_subdomain to false disables this for https.\n// 2) Customers with private cdn\n//   if cdn_domain is true uses cloudname-res-[1-5].cloudinary.com for http\n//   if secure_cdn_domain is true uses cloudname-res-[1-5].cloudinary.com for https (please contact support if you require this)\n// 3) Customers with cname\n//   if cdn_domain is true uses a[1-5].cname for http. For https, uses the same naming scheme as 1 for shared distribution and as 2 for private distribution.\n\n\nfunction unsigned_url_prefix(source, cloud_name, private_cdn, cdn_subdomain, secure_cdn_subdomain, cname, secure, secure_distribution) {\n  var prefix;\n\n  if (cloud_name.indexOf(\"/\") === 0) {\n    return '/res' + cloud_name;\n  }\n\n  var shared_domain = !private_cdn;\n\n  if (secure) {\n    if (secure_distribution == null || secure_distribution === exports.OLD_AKAMAI_SHARED_CDN) {\n      secure_distribution = private_cdn ? cloud_name + \"-res.cloudinary.com\" : exports.SHARED_CDN;\n    }\n\n    if (shared_domain == null) {\n      shared_domain = secure_distribution === exports.SHARED_CDN;\n    }\n\n    if (secure_cdn_subdomain == null && shared_domain) {\n      secure_cdn_subdomain = cdn_subdomain;\n    }\n\n    if (secure_cdn_subdomain) {\n      secure_distribution = secure_distribution.replace('res.cloudinary.com', 'res-' + (crc32(source) % 5 + 1 + '.cloudinary.com'));\n    }\n\n    prefix = 'https://' + secure_distribution;\n  } else if (cname) {\n    var subdomain = cdn_subdomain ? 'a' + (crc32(source) % 5 + 1) + '.' : '';\n    prefix = 'http://' + subdomain + cname;\n  } else {\n    var cdn_part = private_cdn ? cloud_name + '-' : '';\n    var subdomain_part = cdn_subdomain ? '-' + (crc32(source) % 5 + 1) : '';\n    var host = [cdn_part, 'res', subdomain_part, '.cloudinary.com'].join('');\n    prefix = 'http://' + host;\n  }\n\n  if (shared_domain) {\n    prefix += '/' + cloud_name;\n  }\n\n  return prefix;\n} // Based on CGI::unescape. In addition does not escape / :\n//smart_escape = (string)->\n//  encodeURIComponent(string).replace(/%3A/g, \":\").replace(/%2F/g, \"/\")\n\n\nfunction smart_escape(string) {\n  var unsafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /([^a-zA-Z0-9_.\\-\\/:]+)/g;\n  return string.replace(unsafe, function (match) {\n    return match.split(\"\").map(function (c) {\n      return \"%\" + c.charCodeAt(0).toString(16).toUpperCase();\n    }).join(\"\");\n  });\n}\n\nexports.api_url = function api_url() {\n  var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'upload';\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var cloudinary = ensureOption(options, \"upload_prefix\", \"https://api.cloudinary.com\");\n  var cloud_name = ensureOption(options, \"cloud_name\");\n  var resource_type = options[\"resource_type\"] || \"image\";\n  return [cloudinary, \"v1_1\", cloud_name, resource_type, action].join(\"/\");\n};\n\nexports.random_public_id = function random_public_id() {\n  return crypto.randomBytes(12).toString('base64').replace(/[^a-z0-9]/g, \"\");\n};\n\nexports.signed_preloaded_image = function signed_preloaded_image(result) {\n  return \"\".concat(result.resource_type, \"/upload/v\").concat(result.version, \"/\").concat(filter([result.public_id, result.format], utils.present).join(\".\"), \"#\").concat(result.signature);\n};\n\nexports.api_sign_request = function api_sign_request(params_to_sign, api_secret) {\n  var to_sign = entries(params_to_sign).filter(function (_ref21) {\n    var _ref22 = _slicedToArray(_ref21, 2),\n        k = _ref22[0],\n        v = _ref22[1];\n\n    return utils.present(v);\n  }).map(function (_ref23) {\n    var _ref24 = _slicedToArray(_ref23, 2),\n        k = _ref24[0],\n        v = _ref24[1];\n\n    return \"\".concat(k, \"=\").concat(utils.build_array(v).join(\",\"));\n  }).sort().join(\"&\");\n  var shasum = crypto.createHash('sha1');\n  shasum.update(utf8_encode(to_sign + api_secret), 'binary');\n  return shasum.digest('hex');\n};\n\nexports.clear_blank = function clear_blank(hash) {\n  var filtered_hash = {};\n  entries(hash).filter(function (_ref25) {\n    var _ref26 = _slicedToArray(_ref25, 2),\n        k = _ref26[0],\n        v = _ref26[1];\n\n    return utils.present(v);\n  }).forEach(function (_ref27) {\n    var _ref28 = _slicedToArray(_ref27, 2),\n        k = _ref28[0],\n        v = _ref28[1];\n\n    filtered_hash[k] = v;\n  });\n  return filtered_hash;\n};\n\nexports.merge = function merge(hash1, hash2) {\n  return _objectSpread({}, hash1, hash2);\n};\n\nexports.sign_request = function sign_request(params) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var apiKey = ensureOption(options, 'api_key');\n  var apiSecret = ensureOption(options, 'api_secret');\n  params = exports.clear_blank(params);\n  params.signature = exports.api_sign_request(params, apiSecret);\n  params.api_key = apiKey;\n  return params;\n};\n\nexports.webhook_signature = function webhook_signature(data, timestamp) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  ensurePresenceOf({\n    data: data,\n    timestamp: timestamp\n  });\n  var api_secret = ensureOption(options, 'api_secret');\n  var shasum = crypto.createHash('sha1');\n  shasum.update(data + timestamp + api_secret, 'binary');\n  return shasum.digest('hex');\n};\n\nexports.process_request_params = function process_request_params(params, options) {\n  if (options.unsigned != null && options.unsigned) {\n    params = exports.clear_blank(params);\n    delete params[\"timestamp\"];\n  } else {\n    params = exports.sign_request(params, options);\n  }\n\n  return params;\n};\n\nexports.private_download_url = function private_download_url(public_id, format) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var params = exports.sign_request({\n    timestamp: exports.timestamp(),\n    public_id: public_id,\n    format: format,\n    type: options.type,\n    attachment: options.attachment,\n    expires_at: options.expires_at\n  }, options);\n  return exports.api_url(\"download\", options) + \"?\" + querystring.stringify(params);\n};\n/**\n * Utility method that uses the deprecated ZIP download API.\n * @deprecated Replaced by {download_zip_url} that uses the more advanced and robust archive generation and download API\n */\n\n\nexports.zip_download_url = function zip_download_url(tag) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var params = exports.sign_request({\n    timestamp: exports.timestamp(),\n    tag: tag,\n    transformation: utils.generate_transformation_string(options)\n  }, options);\n  return exports.api_url(\"download_tag.zip\", options) + \"?\" + hashToQuery(params);\n};\n/**\n * Returns a URL that when invokes creates an archive and returns it.\n * @param {object} options\n * @param {string} [options.resource_type=\"image\"]  The resource type of files to include in the archive. Must be one of :image | :video | :raw\n * @param {string} [options.type=\"upload\"] The specific file type of resources: :upload|:private|:authenticated\n * @param {string|Array} [options.tags] list of tags to include in the archive\n * @param {string|Array<string>} [options.public_ids] list of public_ids to include in the archive\n * @param {string|Array<string>} [options.prefixes]  list of prefixes of public IDs (e.g., folders).\n * @param {string|Array<string>} [options.transformations]  list of transformations.\n *   The derived images of the given transformations are included in the archive. Using the string representation of\n *   multiple chained transformations as we use for the 'eager' upload parameter.\n * @param {string} [options.mode=\"create\"] return the generated archive file or to store it as a raw resource and\n *   return a JSON with URLs for accessing the archive. Possible values: :download, :create\n * @param {string} [options.target_format=\"zip\"]\n * @param {string} [options.target_public_id]  public ID of the generated raw resource.\n *   Relevant only for the create mode. If not specified, random public ID is generated.\n * @param {boolean} [options.flatten_folders=false] If true, flatten public IDs with folders to be in the root of the archive.\n *   Add numeric counter to the file name in case of a name conflict.\n * @param {boolean} [options.flatten_transformations=false] If true, and multiple transformations are given,\n *   flatten the folder structure of derived images and store the transformation details on the file name instead.\n * @param {boolean} [options.use_original_filename] Use the original file name of included images (if available) instead of the public ID.\n * @param {boolean} [options.async=false] If true, return immediately and perform the archive creation in the background.\n *   Relevant only for the create mode.\n * @param {string} [options.notification_url]  URL to send an HTTP post request (webhook) when the archive creation is completed.\n * @param {string|Array<string>} [options.target_tags=]  array. Allows assigning one or more tag to the generated archive file (for later housekeeping via the admin API).\n * @param {string} [options.keep_derived=false] keep the derived images used for generating the archive\n * @return {String} archive url\n */\n\n\nexports.download_archive_url = function download_archive_url() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var cloudinary_params = exports.sign_request(exports.archive_params(merge(options, {\n    mode: \"download\"\n  })), options);\n  return exports.api_url(\"generate_archive\", options) + \"?\" + hashToQuery(cloudinary_params);\n};\n/**\n * Returns a URL that when invokes creates an zip archive and returns it.\n * @see download_archive_url\n */\n\n\nexports.download_zip_url = function download_zip_url() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return exports.download_archive_url(merge(options, {\n    target_format: \"zip\"\n  }));\n};\n/**\n * Render the key/value pair as an HTML tag attribute\n * @private\n * @param {string} key\n * @param {string|boolean|number} [value]\n * @return {string} A string representing the HTML attribute\n */\n\n\nfunction join_pair(key, value) {\n  if (!value) {\n    return void 0;\n  } else if (value === true) {\n    return key;\n  } else {\n    return key + \"='\" + value + \"'\";\n  }\n}\n/**\n *\n * @param attrs\n * @return {*}\n */\n\n\nexports.html_attrs = function html_attrs(attrs) {\n  return filter(map(attrs, function (value, key) {\n    return join_pair(key, value);\n  })).sort().join(\" \");\n};\n\nvar CLOUDINARY_JS_CONFIG_PARAMS = ['api_key', 'cloud_name', 'private_cdn', 'secure_distribution', 'cdn_subdomain'];\n\nexports.cloudinary_js_config = function cloudinary_js_config() {\n  var params = utils.only.apply(utils, [config()].concat(CLOUDINARY_JS_CONFIG_PARAMS));\n  return \"<script type='text/javascript'>\\n$.cloudinary.config(\".concat(JSON.stringify(params), \");\\n</script>\");\n};\n\nfunction v1_result_adapter(callback) {\n  if (callback != null) {\n    return function (result) {\n      if (result.error != null) {\n        return callback(result.error);\n      } else {\n        return callback(void 0, result);\n      }\n    };\n  } else {\n    return undefined;\n  }\n}\n\nfunction v1_adapter(name, num_pass_args, v1) {\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var pass_args = take(args, num_pass_args);\n    var options = args[num_pass_args];\n    var callback = args[num_pass_args + 1];\n\n    if (callback == null && isFunction(options)) {\n      callback = options;\n      options = {};\n    }\n\n    callback = v1_result_adapter(callback);\n    args = pass_args.concat([callback, options]);\n    return v1[name].apply(this, args);\n  };\n}\n\nexports.v1_adapters = function v1_adapters(exports, v1, mapping) {\n  var name, num_pass_args, results;\n  results = [];\n\n  for (name in mapping) {\n    num_pass_args = mapping[name];\n    results.push(exports[name] = v1_adapter(name, num_pass_args, v1));\n  }\n\n  return results;\n};\n\nexports.as_safe_bool = function as_safe_bool(value) {\n  if (value == null) {\n    return void 0;\n  }\n\n  if (value === true || value === 'true' || value === '1') {\n    value = 1;\n  }\n\n  if (value === false || value === 'false' || value === '0') {\n    value = 0;\n  }\n\n  return value;\n};\n\nvar NUMBER_PATTERN = \"([0-9]*)\\\\.([0-9]+)|([0-9]+)\";\nvar OFFSET_ANY_PATTERN = \"(\".concat(NUMBER_PATTERN, \")([%pP])?\");\nvar RANGE_VALUE_RE = RegExp(\"^\".concat(OFFSET_ANY_PATTERN, \"$\"));\nvar OFFSET_ANY_PATTERN_RE = RegExp(\"(\".concat(OFFSET_ANY_PATTERN, \")\\\\.\\\\.(\").concat(OFFSET_ANY_PATTERN, \")\")); // Split a range into the start and end values\n\nfunction split_range(range) {\n  // :nodoc:\n  switch (range.constructor) {\n    case String:\n      if (OFFSET_ANY_PATTERN_RE.test(range)) {\n        return range.split(\"..\");\n      }\n\n      break;\n\n    case Array:\n      return [first(range), last(range)];\n\n    default:\n      return [null, null];\n  }\n}\n\nfunction norm_range_value(value) {\n  // :nodoc:\n  var offset = String(value).match(RANGE_VALUE_RE);\n\n  if (offset) {\n    var modifier = offset[5] ? 'p' : '';\n    value = \"\".concat(offset[1] || offset[4]).concat(modifier);\n  }\n\n  return value;\n}\n/**\n * A video codec parameter can be either a String or a Hash.\n * @param {Object} param <code>vc_<codec>[ : <profile> : [<level>]]</code>\n *                       or <code>{ codec: 'h264', profile: 'basic', level: '3.1' }</code>\n * @return {String} <code><codec> : <profile> : [<level>]]</code> if a Hash was provided\n *                   or the param if a String was provided.\n *                   Returns null if param is not a Hash or String\n */\n\n\nfunction process_video_params(param) {\n  switch (param.constructor) {\n    case Object:\n      var video = \"\";\n\n      if ('codec' in param) {\n        video = param['codec'];\n\n        if ('profile' in param) {\n          video += \":\" + param['profile'];\n\n          if ('level' in param) {\n            video += \":\" + param['level'];\n          }\n        }\n      }\n\n      return video;\n\n    case String:\n      return param;\n\n    default:\n      return null;\n  }\n}\n/**\n * Returns a Hash of parameters used to create an archive\n * @private\n * @param {object} options\n * @return {object} Archive API parameters\n */\n\n\nexports.archive_params = function archive_params() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return {\n    allow_missing: exports.as_safe_bool(options.allow_missing),\n    async: exports.as_safe_bool(options.async),\n    expires_at: options.expires_at,\n    flatten_folders: exports.as_safe_bool(options.flatten_folders),\n    flatten_transformations: exports.as_safe_bool(options.flatten_transformations),\n    keep_derived: exports.as_safe_bool(options.keep_derived),\n    mode: options.mode,\n    notification_url: options.notification_url,\n    prefixes: options.prefixes && exports.build_array(options.prefixes),\n    public_ids: options.public_ids && exports.build_array(options.public_ids),\n    skip_transformation_name: exports.as_safe_bool(options.skip_transformation_name),\n    tags: options.tags && exports.build_array(options.tags),\n    target_format: options.target_format,\n    target_public_id: options.target_public_id,\n    target_tags: options.target_tags && exports.build_array(options.target_tags),\n    timestamp: options.timestamp ? options.timestamp : exports.timestamp(),\n    transformations: utils.build_eager(options.transformations),\n    type: options.type,\n    use_original_filename: exports.as_safe_bool(options.use_original_filename)\n  };\n};\n\nexports.build_explicit_api_params = function build_explicit_api_params(public_id) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return [exports.build_upload_params(extend({}, {\n    public_id: public_id\n  }, options))];\n};\n\nexports.generate_responsive_breakpoints_string = function generate_responsive_breakpoints_string(breakpoints) {\n  if (breakpoints == null) {\n    return;\n  }\n\n  breakpoints = clone(breakpoints);\n\n  if (!isArray(breakpoints)) {\n    breakpoints = [breakpoints];\n  }\n\n  for (var j = 0; j < breakpoints.length; j++) {\n    var breakpoint_settings = breakpoints[j];\n\n    if (breakpoint_settings != null) {\n      if (breakpoint_settings.transformation) {\n        breakpoint_settings.transformation = utils.generate_transformation_string(clone(breakpoint_settings.transformation));\n      }\n    }\n  }\n\n  return JSON.stringify(breakpoints);\n};\n\nexports.build_streaming_profiles_param = function build_streaming_profiles_param() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var params = utils.only(options, \"display_name\", \"representations\");\n\n  if (isArray(params[\"representations\"])) {\n    params[\"representations\"] = JSON.stringify(params[\"representations\"].map(function (r) {\n      return {\n        transformation: utils.generate_transformation_string(r.transformation)\n      };\n    }));\n  }\n\n  return params;\n};\n/**\n * Convert a hash of values to a URI query string.\n * Array values are spread as individual parameters.\n * @param {object} hash Key-value parameters\n * @return {string} A URI query string.\n */\n\n\nfunction hashToQuery(hash) {\n  return entries(hash).reduce(function (entries, _ref29) {\n    var _ref30 = _slicedToArray(_ref29, 2),\n        key = _ref30[0],\n        value = _ref30[1];\n\n    if (isArray(value)) {\n      key = key.endsWith('[]') ? key : key + '[]';\n      var items = value.map(function (v) {\n        return [key, v];\n      });\n      entries = entries.concat(items);\n    } else {\n      entries.push([key, value]);\n    }\n\n    return entries;\n  }, []).map(function (_ref31) {\n    var _ref32 = _slicedToArray(_ref31, 2),\n        key = _ref32[0],\n        value = _ref32[1];\n\n    return \"\".concat(querystring.escape(key), \"=\").concat(querystring.escape(value));\n  }).join('&');\n}\n/**\n * Verify that the parameter `value` is defined and it's string value is not zero.\n * <br>This function should not be confused with `isEmpty()`.\n * @private\n * @param {string|number} value The value to check.\n * @return {boolean} True if the value is defined and not empty.\n */\n\n\nexports.present = function present(value) {\n  return value != null && (\"\" + value).length > 0;\n};\n/**\n * Returns a new object with key values from source based on the keys.\n * `null` or `undefined` values are not copied.\n * @private\n * @param {object} source The object to pick values from.\n * @param {...string} keys One or more keys to copy from source.\n * @return {object} A new object with the required keys and values.\n */\n\n\nexports.only = function only(source) {\n  var result = {};\n\n  if (source) {\n    for (var j = 0; j < (arguments.length <= 1 ? 0 : arguments.length - 1); j++) {\n      var key = j + 1 < 1 || arguments.length <= j + 1 ? undefined : arguments[j + 1];\n\n      if (source[key] != null) {\n        result[key] = source[key];\n      }\n    }\n  }\n\n  return result;\n};\n/**\n * Returns a JSON array as String.\n * Yields the array before it is converted to JSON format\n * @private\n * @param {object|String|Array<object>} data\n * @param {function(*):*} [modifier] called with the array before the array is stringified\n * @return {String|null} a JSON array string or `null` if data is `null`\n */\n\n\nexports.jsonArrayParam = function jsonArrayParam(data, modifier) {\n  if (!data) {\n    return null;\n  }\n\n  if (isString(data)) {\n    data = JSON.parse(data);\n  }\n\n  if (!isArray(data)) {\n    data = [data];\n  }\n\n  if (isFunction(modifier)) {\n    data = modifier(data);\n  }\n\n  return JSON.stringify(data);\n};\n/**\n * Empty function - do nothing\n *\n */\n\n\nexports.NOP = function () {};","map":null,"metadata":{},"sourceType":"script"}