{"ast":null,"code":"\"use strict\";\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar CACHE = Symbol.for(\"com.cloudinary.cache\");\nvar CACHE_ADAPTER = Symbol.for(\"com.cloudinary.cacheAdapter\");\n\nvar utils = require('./utils');\n\nvar ensurePresenceOf = utils.ensurePresenceOf;\n/**\n * The adapter used to communicate with the underlying cache storage\n */\n\nvar CacheAdapter = function () {\n  function CacheAdapter(storage) {\n    _classCallCheck(this, CacheAdapter);\n  }\n  /**\n   * Get a value from the cache\n   * @param {string} publicId\n   * @param {string} type\n   * @param {string} resourceType\n   * @param {string} transformation\n   * @return {*} the value associated with the provided arguments\n   */\n\n\n  _createClass(CacheAdapter, [{\n    key: \"get\",\n    value: function get(publicId, type, resourceType, transformation, format) {}\n    /**\n     * Set a new value in the cache\n     * @param {string} publicId\n     * @param {string} type\n     * @param {string} resourceType\n     * @param {string} transformation\n     * @param {*} value\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(publicId, type, resourceType, transformation, format, value) {}\n    /**\n     * Delete all values in the cache\n     */\n\n  }, {\n    key: \"flushAll\",\n    value: function flushAll() {}\n  }]);\n\n  return CacheAdapter;\n}();\n/**\n * @class Cache\n * Stores and retrieves values identified by publicId / options pairs\n */\n\n\nvar Cache = {\n  /**\n   * The adapter interface. Extend this class to implement a specific adapter.\n   * @type CacheAdapter\n   */\n  CacheAdapter: CacheAdapter,\n\n  /**\n   * Set the cache adapter\n   * @param {CacheAdapter} adapter The cache adapter\n   */\n  setAdapter: function setAdapter(adapter) {\n    if (this.adapter) {\n      console.warn(\"Overriding existing cache adapter\");\n    }\n\n    this.adapter = adapter;\n  },\n\n  /**\n   * Get the adapter the Cache is using\n   * @return {CacheAdapter} the current cache adapter\n   */\n  getAdapter: function getAdapter() {\n    return this.adapter;\n  },\n\n  /**\n   * Get an item from the cache\n   * @param {string} publicId\n   * @param {object} options\n   * @return {*}\n   */\n  get: function get(publicId, options) {\n    if (!this.adapter) {\n      return undefined;\n    }\n\n    ensurePresenceOf({\n      publicId: publicId\n    });\n    var transformation = utils.generate_transformation_string(_extends({}, options));\n    return this.adapter.get(publicId, options.type || 'upload', options.resource_type || 'image', transformation, options.format);\n  },\n\n  /**\n   * Set a new value in the cache\n   * @param {string} publicId\n   * @param {object} options\n   * @param {*} value\n   * @return {*}\n   */\n  set: function set(publicId, options, value) {\n    if (!this.adapter) {\n      return undefined;\n    }\n\n    ensurePresenceOf({\n      publicId: publicId,\n      value: value\n    });\n    var transformation = utils.generate_transformation_string(_extends({}, options));\n    return this.adapter.set(publicId, options.type || 'upload', options.resource_type || 'image', transformation, options.format, value);\n  },\n\n  /**\n   * Clear all items in the cache\n   * @return {*} Returns the value from the adapter's flushAll() method\n   */\n  flushAll: function flushAll() {\n    if (!this.adapter) {\n      return undefined;\n    }\n\n    return this.adapter.flushAll();\n  }\n}; // Define singleton property\n\nObject.defineProperty(Cache, \"instance\", {\n  get: function get() {\n    return global[CACHE];\n  }\n});\nObject.defineProperty(Cache, \"adapter\", {\n  /**\n   *\n   * @return {CacheAdapter} The current cache adapter\n   */\n  get: function get() {\n    return global[CACHE_ADAPTER];\n  },\n\n  /**\n   * Set the cache adapter to be used by Cache\n   * @param {CacheAdapter} adapter Cache adapter\n   */\n  set: function set(adapter) {\n    global[CACHE_ADAPTER] = adapter;\n  }\n});\nObject.freeze(Cache); // Instantiate singleton\n\nvar symbols = Object.getOwnPropertySymbols(global);\n\nif (symbols.indexOf(CACHE) < 0) {\n  global[CACHE] = Cache;\n}\n/**\n * Store key value pairs\n\n */\n\n\nmodule.exports = Cache;","map":null,"metadata":{},"sourceType":"script"}